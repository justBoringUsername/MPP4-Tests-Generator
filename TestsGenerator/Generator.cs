using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;
using TestsGenerator.IO;
using TestsGenerator.Options;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace TestsGenerator
{
    public class Generator
    {
        private readonly GeneratorOptions options;
        private readonly ClassReader reader;
        private readonly ClassWriter writer;

        private MethodDeclarationSyntax MethodDeclar(string name)
        {
            return MethodDeclaration(PredefinedType(Token(SyntaxKind.VoidKeyword)), Identifier(name + "_" + "Test")).WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(Attribute(IdentifierName("TestMethod"))))))
                .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                .WithBody(Block(ExpressionStatement(InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName("Assert"), IdentifierName("Fail")))
                .WithArgumentList(ArgumentList(SingletonSeparatedList(Argument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal("autogenerated")))))))));
        }

        private MemberDeclarationSyntax ClassDeclar(string name, List<MemberDeclarationSyntax> methods)
        {
            return ClassDeclaration(name).WithAttributeLists(SingletonList(AttributeList(SingletonSeparatedList(Attribute(IdentifierName("TestClass"))))))
                .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                .WithMembers(List(methods));
        }

        private CompilationUnitSyntax ResultDeclar(List<UsingDirectiveSyntax> usingsSyntaxes, MemberDeclarationSyntax member, string param)
        {
            return CompilationUnit().WithUsings(List(usingsSyntaxes)).WithMembers(SingletonList<MemberDeclarationSyntax>(NamespaceDeclaration(QualifiedName(IdentifierName(param), IdentifierName("Test")))))
                .WithMembers(SingletonList(member));
        }

        public Generator(GeneratorOptions options, ClassReader reader, ClassWriter writer)
        {
            this.options = options;
            this.reader = reader;
            this.writer = writer;
        }
        private List<ClassInfo> GenerateClassInfoes(string classs)
        {

            CompilationUnitSyntax unitSyntax = ParseCompilationUnit(classs);
            var classes = unitSyntax.DescendantNodes().OfType<ClassDeclarationSyntax>();
            List<ClassInfo> ClassInfoes = new List<ClassInfo>();
            List<UsingDirectiveSyntax> usings = new List<UsingDirectiveSyntax>(unitSyntax.DescendantNodes().OfType<UsingDirectiveSyntax>());
            usings.Add(UsingDirective(QualifiedName(IdentifierName("Microsoft.VisualStudio"), IdentifierName("TestTools.UnitTesting"))));
            foreach (var clas in classes)
            {
                var methods = clas.DescendantNodes().OfType<MethodDeclarationSyntax>().Where(x => x.Modifiers.Any(y => y.ValueText == "public"));
                string nameSpace = (clas.Parent as NamespaceDeclarationSyntax)?.Name.ToString();
                List<MemberDeclarationSyntax> members = new List<MemberDeclarationSyntax>();
                foreach (var method in methods)
                {
                    string name = method.Identifier.ToString();
                    int count = 1;
                    if (members.Count != 0 && members.Any(x => (x as MethodDeclarationSyntax)?.Identifier.ToString() == method.Identifier.ToString() + "_Test"))
                    {
                        while (members.Any(x => (x as MethodDeclarationSyntax)?.Identifier.ToString() == method.Identifier.ToString() + count + "_Test"))
                        {
                            count++;
                        }

                        name += count;
                    }
                    members.Add(MethodDeclar(name));
                }
                var classdeclar = ClassDeclar(clas.Identifier.ValueText + "Test", members);
                if (nameSpace == null)
                {
                    ClassInfoes.Add(new ClassInfo(clas.Identifier.ValueText + "Test", ResultDeclar(usings, classdeclar, "Global").NormalizeWhitespace().ToFullString()));
                }
                else
                {
                    usings.Add(UsingDirective((clas.Parent as NamespaceDeclarationSyntax).Name));
                    ClassInfoes.Add(new ClassInfo(clas.Identifier.ValueText + "Test", ResultDeclar(usings, classdeclar, nameSpace).NormalizeWhitespace().ToFullString()));
                    usings.RemoveAt(usings.Count - 1);
                }
            }
            return ClassInfoes;
        }
        public Task Generate(List<string> files)
        {
            ExecutionDataflowBlockOptions maxreadfiles = new ExecutionDataflowBlockOptions
            {
                MaxDegreeOfParallelism = options.maxReadCoount
            };

            ExecutionDataflowBlockOptions maxprocessfiles = new ExecutionDataflowBlockOptions
            {
                MaxDegreeOfParallelism = options.maxProcessCount
            };

            ExecutionDataflowBlockOptions maxwritefiles = new ExecutionDataflowBlockOptions
            {
                MaxDegreeOfParallelism = options.maxWriteCount
            };

            var readfiles = new TransformBlock<string, string>(
                new Func<string, Task<string>>(ClassReader.Read),
                 maxreadfiles);
            var processfiles = new TransformBlock<string, List<ClassInfo>>(
               new Func<string, List<ClassInfo>>(GenerateClassInfoes),
                maxprocessfiles);
            var writesfiles = new ActionBlock<List<ClassInfo>>(
              async (x) => await writer.Write(x),
               maxprocessfiles);

            readfiles.LinkTo(processfiles, new DataflowLinkOptions() { PropagateCompletion = true });
            processfiles.LinkTo(writesfiles, new DataflowLinkOptions() { PropagateCompletion = true });

            foreach (var file in files)
            {
                readfiles.Post(file);
            }

            readfiles.Complete();
            return writesfiles.Completion;
        }
    }
}

